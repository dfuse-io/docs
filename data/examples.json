{
  "quickstarts_go_eos_section1": "package main\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"os\"\n\t\"time\"\n\n\tpb \"github.com/dfuse-io/docs/quickstarts/go/pb\"\n\t\"github.com/tidwall/gjson\"\n\t\"golang.org/x/oauth2\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials\"\n\t\"google.golang.org/grpc/credentials/oauth\"\n)\n",
  "quickstarts_go_eos_section2": "func getToken(apiKey string) (token string, expiration time.Time, err error) {\n\treqBody := bytes.NewBuffer([]byte(fmt.Sprintf(`{\"api_key\":\"%s\"}`, apiKey)))\n\tresp, err := http.Post(\"https://auth.dfuse.io/v1/auth/issue\", \"application/json\", reqBody)\n\tif err != nil {\n\t\terr = fmt.Errorf(\"unable to obtain token: %s\", err)\n\t\treturn\n\t}\n\n\tif resp.StatusCode != 200 {\n\t\terr = fmt.Errorf(\"unable to obtain token, status not 200, got %d: %s\", resp.StatusCode, reqBody.String())\n\t\treturn\n\t}\n\n\tif body, err := ioutil.ReadAll(resp.Body); err == nil {\n\t\ttoken = gjson.GetBytes(body, \"token\").String()\n\t\texpiration = time.Unix(gjson.GetBytes(body, \"expires_at\").Int(), 0)\n\t}\n\treturn\n}\n",
  "quickstarts_go_eos_section3": "func createClient(endpoint string) pb.GraphQLClient {\n\tdfuseAPIKey := os.Getenv(\"DFUSE_API_KEY\")\n\tif dfuseAPIKey == \"\" {\n\t\tpanic(\"you must specify a DFUSE_API_KEY environment variable\")\n\t}\n\n\ttoken, _, err := getToken(dfuseAPIKey)\n\tpanicIfError(err)\n\n\tcredential := oauth.NewOauthAccess(&oauth2.Token{AccessToken: token, TokenType: \"Bearer\"})\n\ttransportCreds := credentials.NewClientTLSFromCert(nil, \"\")\n\tconn, err := grpc.Dial(endpoint,\n\t\tgrpc.WithPerRPCCredentials(credential),\n\t\tgrpc.WithTransportCredentials(transportCreds),\n\t)\n\tpanicIfError(err)\n\n\treturn pb.NewGraphQLClient(conn)\n}\n",
  "quickstarts_go_eos_section4": "const operationEOS = `subscription {\n  searchTransactionsForward(query:\"receiver:eosio.token action:transfer -data.quantity:'0.0001 EOS'\") {\n    undo cursor\n    trace { id matchingActions { json } }\n  }\n}`\n\ntype eosioDocument struct {\n\tSearchTransactionsForward struct {\n\t\tCursor string\n\t\tUndo   bool\n\t\tTrace  struct {\n\t\t\tID              string\n\t\t\tMatchingActions []struct {\n\t\t\t\tJSON map[string]interface{}\n\t\t\t}\n\t\t}\n\t}\n}\n",
  "quickstarts_go_eos_section5": "func streamEOSIO(ctx context.Context) {\n\t/* The client can be re-used for all requests, cache it at the appropriate level */\n\tclient := createClient(\"mainnet.eos.dfuse.io:443\")\n\texecutor, err := client.Execute(ctx, &pb.Request{Query: operationEOS})\n\tpanicIfError(err)\n\n\tfor {\n\t\tresp, err := executor.Recv()\n\t\tpanicIfError(err)\n\n\t\tif len(resp.Errors) > 0 {\n\t\t\tfor _, err := range resp.Errors {\n\t\t\t\tfmt.Printf(\"Request failed: %s\\n\", err)\n\t\t\t}\n\n\t\t\t/* We continue here, but you could take another decision here, like exiting the process */\n\t\t\tcontinue\n\t\t}\n\n\t\tdocument := &eosioDocument{}\n\t\terr = json.Unmarshal([]byte(resp.Data), document)\n\t\tpanicIfError(err)\n\n\t\tresult := document.SearchTransactionsForward\n\t\treverted := \"\"\n\t\tif result.Undo {\n\t\t\treverted = \" REVERTED\"\n\t\t}\n\n\t\tfor _, action := range result.Trace.MatchingActions {\n\t\t\tdata := action.JSON\n\t\t\tfmt.Printf(\"Transfer %s -> %s [%s]%s\\n\", data[\"from\"], data[\"to\"], data[\"quantity\"], reverted)\n\t\t}\n\t}\n}\n",
  "quickstarts_go_eos_section6": "func main() {\n\tproto := \"\"\n\tif len(os.Args) >= 2 {\n\t\tproto = os.Args[1]\n\t}\n\n\tswitch proto {\n\tcase \"ethereum\", \"ETH\":\n\t\tstreamEthereum(context.Background())\n\tdefault:\n\t\tstreamEOSIO(context.Background())\n\t}\n}\n\nfunc panicIfError(err error) {\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n",
  "quickstarts_go_ethereum_section1": "package main\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"os\"\n\t\"time\"\n\n\tpb \"github.com/dfuse-io/docs/quickstarts/go/pb\"\n\n\t\"github.com/tidwall/gjson\"\n\t\"golang.org/x/oauth2\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/credentials\"\n\t\"google.golang.org/grpc/credentials/oauth\"\n)\n\nfunc main() {\n\n\tdfuseAPIKey := os.Getenv(\"DFUSE_API_KEY\")\n\tif dfuseAPIKey == \"\" || dfuseAPIKey == \"your dfuse api key here\" {\n\t\tpanic(\"you must specify a DFUSE_API_KEY environment variable\")\n\t}\n\n\ttoken, _, err := getToken(dfuseAPIKey)\n\tpanicIfError(err)\n\n\tclient := createClient(\"mainnet.eth.dfuse.io:443\", token)\n\n\tstreamEthereum(context.Background(), client)\n}\n\nfunc panicIfError(err error) {\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n",
  "quickstarts_go_ethereum_section2": "func getToken(apiKey string) (token string, expiration time.Time, err error) {\n\treqBody := bytes.NewBuffer([]byte(fmt.Sprintf(`{\"api_key\":\"%s\"}`, apiKey)))\n\tresp, err := http.Post(\"https://auth.dfuse.io/v1/auth/issue\", \"application/json\", reqBody)\n\tif err != nil {\n\t\terr = fmt.Errorf(\"unable to obtain token: %s\", err)\n\t\treturn\n\t}\n\n\tif resp.StatusCode != 200 {\n\t\terr = fmt.Errorf(\"unable to obtain token, status not 200, got %d: %s\", resp.StatusCode, reqBody.String())\n\t\treturn\n\t}\n\n\tif body, err := ioutil.ReadAll(resp.Body); err == nil {\n\t\ttoken = gjson.GetBytes(body, \"token\").String()\n\t\texpiration = time.Unix(gjson.GetBytes(body, \"expires_at\").Int(), 0)\n\t}\n\treturn\n}\n",
  "quickstarts_go_ethereum_section3": "func createClient(endpoint string, token string) pb.GraphQLClient {\n\n\tcredential := oauth.NewOauthAccess(&oauth2.Token{AccessToken: token, TokenType: \"Bearer\"})\n\ttransportCreds := credentials.NewClientTLSFromCert(nil, \"\")\n\tconn, err := grpc.Dial(endpoint,\n\t\tgrpc.WithPerRPCCredentials(credential),\n\t\tgrpc.WithTransportCredentials(transportCreds),\n\t)\n\tpanicIfError(err)\n\n\treturn pb.NewGraphQLClient(conn)\n}\n",
  "quickstarts_go_ethereum_section4": "const operationETH = `subscription {\n  searchTransactions(indexName:CALLS, query:\"-value:0 type:call\", lowBlockNum: -1) {\n    undo cursor\n    node { hash matchingCalls { from to value(encoding:ETHER) } }\n  }\n}`\n\ntype ethereumDocument struct {\n\tSearchTransactions struct {\n\t\tCursor string\n\t\tUndo   bool\n\t\tNode   struct {\n\t\t\tHash          string\n\t\t\tMatchingCalls []struct {\n\t\t\t\tFrom  string\n\t\t\t\tTo    string\n\t\t\t\tValue string\n\t\t\t}\n\t\t}\n\t}\n}\n",
  "quickstarts_go_ethereum_section5": "func streamEthereum(ctx context.Context, client pb.GraphQLClient) {\n\n\texecutor, err := client.Execute(ctx, &pb.Request{Query: operationETH})\n\tpanicIfError(err)\n\n\tfor {\n\t\tresp, err := executor.Recv()\n\t\tpanicIfError(err)\n\n\t\tif len(resp.Errors) > 0 {\n\t\t\tfor _, err := range resp.Errors {\n\t\t\t\tfmt.Printf(\"Request failed: %s\\n\", err)\n\t\t\t}\n\n\t\t\t/* We continue here, but you could take another decision here, like exiting the process */\n\t\t\tcontinue\n\t\t}\n\n\t\tdocument := &ethereumDocument{}\n\t\terr = json.Unmarshal([]byte(resp.Data), document)\n\t\tpanicIfError(err)\n\n\t\tresult := document.SearchTransactions\n\t\treverted := \"\"\n\t\tif result.Undo {\n\t\t\treverted = \" REVERTED\"\n\t\t}\n\n\t\tfor _, call := range result.Node.MatchingCalls {\n\t\t\tfmt.Printf(\"Transfer %s -> %s [%s Ether]%s\\n\", call.From, call.To, call.Value, reverted)\n\t\t}\n\t}\n}\n",
  "quickstarts_javascript_browser_eos_section1": "<head>\n    <style> li { font-family: monospace; margin: 0.15; }</style>\n    <script src=\"https://unpkg.com/@dfuse/client\"></script>\n    <script>\n        const client = dfuseClient.createDfuseClient({\n          // Replace 'web_abcdef12345678900000000000' with your own API key!\n          apiKey: 'web_abcdef12345678900000000000',\n          network: 'mainnet.eos.dfuse.io'\n        })\n    </script>\n</head>",
  "quickstarts_javascript_browser_eos_section2": "<script>\n// You must use a `$cursor` variable so stream starts back at last marked cursor on reconnect!\nconst operation = `subscription($cursor: String!) {\n  searchTransactionsForward(query:\"receiver:eosio.token action:transfer -data.quantity:'0.0001 EOS'\", cursor: $cursor) {\n    undo cursor\n    trace { id matchingActions { json } }\n  }\n}`\n</script>",
  "quickstarts_javascript_browser_eos_section3": "<script>\nasync function main() {\n  const stream = await client.graphql(operation, (message) => {\n    if (message.type === \"data\") {\n      const { undo, cursor, trace: { id, matchingActions }} = message.data.searchTransactionsForward\n      matchingActions.forEach(({ json: { from, to, quantity } }) => {\n        const paragraphNode = document.createElement(\"li\")\n        paragraphNode.innerText = `Transfer ${from} -> ${to} [${quantity}]${undo ? \" REVERTED\" : \"\"}`\n\n        document.body.prepend(paragraphNode)\n      })\n\n      // Mark stream at cursor location, on re-connect, we will start back at cursor\n      stream.mark({ cursor })\n    }\n\n    if (message.type === \"error\") {\n      const { errors, terminal } = message\n      const paragraphNode = document.createElement(\"li\")\n      paragraphNode.innerText = `An error occurred ${JSON.stringify({ errors, terminal })}`\n\n      document.body.prepend(paragraphNode)\n    }\n\n    if (message.type === \"complete\") {\n        const paragraphNode = document.createElement(\"li\")\n        paragraphNode.innerText = \"Completed\"\n\n        document.body.prepend(paragraphNode)\n    }\n  })\n\n  // Waits until the stream completes, or forever\n  await stream.join()\n  await client.release()\n}\n</script>",
  "quickstarts_javascript_browser_eos_section4": "<script>\nmain().catch((error) => document.body.innerHTML = `<p>${error}</p>`)\n</script>",
  "quickstarts_javascript_browser_ethereum_section1": "<head>\n    <style> li { font-family: monospace; margin: 0.15; }</style>\n    <script src=\"https://unpkg.com/@dfuse/client\"></script>\n    <script>\n        const client = dfuseClient.createDfuseClient({\n          // Replace 'web_abcdef12345678900000000000' with your own API key!\n          apiKey: 'web_abcdef12345678900000000000',\n          network: 'mainnet.eth.dfuse.io'\n        })\n    </script>\n</head>",
  "quickstarts_javascript_browser_ethereum_section2": "<script>\n// You must use a `$cursor` variable so stream starts back at last marked cursor on reconnect!\nconst operation = `subscription($cursor: String!) {\n  searchTransactions(indexName:CALLS, query:\"-value:0 type:call\", lowBlockNum: -1, cursor: $cursor) {\n    undo cursor\n    node { hash matchingCalls { from to value(encoding:ETHER) } }\n  }\n}`\n</script>",
  "quickstarts_javascript_browser_ethereum_section3": "<script>\nasync function main() {\n  const stream = await client.graphql(operation, (message) => {\n    if (message.type === \"data\") {\n      const { undo, cursor, node: { hash, value, matchingCalls }} = message.data.searchTransactions\n      matchingCalls.forEach(({ from, to, value }) => {\n        const paragraphNode = document.createElement(\"li\")\n        paragraphNode.innerText = `Transfer ${from} -> ${to} [${value} Ether]${undo ? \" REVERTED\" : \"\"}`\n\n        document.body.prepend(paragraphNode)\n      })\n\n      // Mark stream at cursor location, on re-connect, we will start back at cursor\n      stream.mark({ cursor })\n    }\n\n    if (message.type === \"error\") {\n      const { errors, terminal } = message\n      const paragraphNode = document.createElement(\"li\")\n      paragraphNode.innerText = `An error occurred ${JSON.stringify({ errors, terminal })}`\n\n      document.body.prepend(paragraphNode)\n    }\n\n    if (message.type === \"complete\") {\n        const paragraphNode = document.createElement(\"li\")\n        paragraphNode.innerText = \"Completed\"\n\n        document.body.prepend(paragraphNode)\n    }\n  })\n\n  // Waits until the stream completes, or forever\n  await stream.join()\n  await client.release()\n}\n</script>",
  "quickstarts_javascript_browser_ethereum_section4": "<script>\nmain().catch((error) => document.body.innerHTML = `<p>${error}</p>`)\n</script>",
  "quickstarts_javascript_bundler_eos_section1": "import { createDfuseClient } from \"@dfuse/client\"\n\nconst client = createDfuseClient({\n  apiKey: process.env.DFUSE_API_KEY,\n  network: \"mainnet.eos.dfuse.io\",\n})",
  "quickstarts_javascript_bundler_eos_section2": "// You must use a `$cursor` variable so stream starts back at last marked cursor on reconnect!\nconst operation = `subscription($cursor: String!) {\n  searchTransactionsForward(query:\"receiver:eosio.token action:transfer -data.quantity:'0.0001 EOS'\", cursor: $cursor) {\n    undo cursor\n    trace { id matchingActions { json } }\n  }\n}`",
  "quickstarts_javascript_bundler_eos_section3": "// You would normally use your framework entry point and render using components,\n// we are using pure HTML manipulation for sake of example simplicity.\nasync function main() {\n  const stream = await client.graphql(operation, (message) => {\n    if (message.type === \"data\") {\n      const { undo, cursor, trace: { id, matchingActions }} = message.data.searchTransactionsForward\n      matchingActions.forEach(({ json: { from, to, quantity } }) => {\n        const paragraphNode = document.createElement(\"li\")\n        paragraphNode.innerText = `Transfer ${from} -> ${to} [${quantity}]${undo ? \" REVERTED\" : \"\"}`\n\n        document.body.prepend(paragraphNode)\n      })\n\n      // Mark stream at cursor location, on re-connect, we will start back at cursor\n      stream.mark({ cursor })\n    }\n\n    if (message.type === \"error\") {\n      const { errors, terminal } = message\n      const paragraphNode = document.createElement(\"li\")\n      paragraphNode.innerText = `An error occurred ${JSON.stringify({ errors, terminal })}`\n\n      document.body.prepend(paragraphNode)\n    }\n\n    if (message.type === \"complete\") {\n        const paragraphNode = document.createElement(\"li\")\n        paragraphNode.innerText = \"Completed\"\n\n        document.body.prepend(paragraphNode)\n    }\n  })\n\n  // Waits until the stream completes, or forever\n  await stream.join()\n  await client.release()\n}",
  "quickstarts_javascript_bundler_eos_section4": "main().catch((error) => document.body.innerHTML = `<p>${error}</p>`)",
  "quickstarts_javascript_bundler_ethereum_section1": "const { createDfuseClient } = require(\"@dfuse/client\")\n\nconst client = createDfuseClient({\n  apiKey: process.env.DFUSE_API_KEY,\n  network: \"mainnet.eth.dfuse.io\",\n})",
  "quickstarts_javascript_bundler_ethereum_section2": "// You must use a `$cursor` variable so stream starts back at last marked cursor on reconnect!\nconst operation = `subscription($cursor: String!) {\n  searchTransactions(indexName:CALLS, query:\"-value:0 type:call\", lowBlockNum: -1, cursor: $cursor) {\n    undo cursor\n    node { hash matchingCalls { from to value(encoding:ETHER) } }\n  }\n}`",
  "quickstarts_javascript_bundler_ethereum_section3": "// You would normally use your framework entry point and render using components,\n// we are using pure HTML manipulation for sake of example simplicity.\nasync function main() {\n  const stream = await client.graphql(operation, (message) => {\n    if (message.type === \"data\") {\n      const { undo, cursor, node: { hash, value, matchingCalls }} = message.data.searchTransactions\n      matchingCalls.forEach(({ from, to, value }) => {\n        const paragraphNode = document.createElement(\"li\")\n        paragraphNode.innerText = `Transfer ${from} -> ${to} [${value} Ether]${undo ? \" REVERTED\" : \"\"}`\n\n        document.body.prepend(paragraphNode)\n      })\n\n      // Mark stream at cursor location, on re-connect, we will start back at cursor\n      stream.mark({ cursor })\n    }\n\n    if (message.type === \"error\") {\n      const { errors, terminal } = message\n      const paragraphNode = document.createElement(\"li\")\n      paragraphNode.innerText = `An error occurred ${JSON.stringify({ errors, terminal })}`\n\n      document.body.prepend(paragraphNode)\n    }\n\n    if (message.type === \"complete\") {\n        const paragraphNode = document.createElement(\"li\")\n        paragraphNode.innerText = \"Completed\"\n\n        document.body.prepend(paragraphNode)\n    }\n  })\n\n  // Waits until the stream completes, or forever\n  await stream.join()\n  await client.release()\n}",
  "quickstarts_javascript_bundler_ethereum_section4": "main().catch((error) => document.body.innerHTML = `<p>${error}</p>`)",
  "quickstarts_javascript_node_eos_section1": "const { createDfuseClient } = require('@dfuse/client');\n\nconst client = createDfuseClient({\n  apiKey: process.env.DFUSE_API_KEY,\n  network: 'mainnet.eos.dfuse.io'\n});",
  "quickstarts_javascript_node_eos_section2": "// You must use a `$cursor` variable so stream starts back at last marked cursor on reconnect!\nconst operation = `subscription($cursor: String!) {\n  searchTransactionsForward(query:\"receiver:eosio.token action:transfer -data.quantity:'0.0001 EOS'\", cursor: $cursor) {\n    undo cursor\n    trace { id matchingActions { json } }\n  }\n}`;",
  "quickstarts_javascript_node_eos_section3": "async function main() {\n  const stream = await client.graphql(operation, message => {\n    if (message.type === 'data') {\n      const {\n        undo,\n        cursor,\n        trace: { id, matchingActions }\n      } = message.data.searchTransactionsForward;\n      matchingActions.forEach(({ json: { from, to, quantity } }) => {\n        console.log(\n          `Transfer ${from} -> ${to} [${quantity}]${undo ? ' REVERTED' : ''}`\n        );\n      });\n\n      // Mark stream at cursor location, on re-connect, we will start back at cursor\n      stream.mark({ cursor });\n    }\n\n    if (message.type === 'error') {\n      console.log('An error occurred', message.errors, message.terminal);\n    }\n\n    if (message.type === 'complete') {\n      console.log('Completed');\n    }\n  });\n\n  // Waits until the stream completes, or forever\n  await stream.join();\n  await client.release();\n}",
  "quickstarts_javascript_node_eos_section4": "main().catch(error => console.log('Unexpected error', error));",
  "quickstarts_javascript_node_ethereum_section1": "const { createDfuseClient } = require(\"@dfuse/client\")\n\nconst client = createDfuseClient({\n  apiKey: process.env.DFUSE_API_KEY,\n  network: \"mainnet.eth.dfuse.io\",\n})",
  "quickstarts_javascript_node_ethereum_section2": "// You must use a `$cursor` variable so stream starts back at last marked cursor on reconnect!\nconst operation = `subscription($cursor: String!) {\n  searchTransactions(indexName:CALLS, query:\"-value:0 type:call\", lowBlockNum: -1, cursor: $cursor) {\n    undo cursor\n    node { hash matchingCalls { from to value(encoding:ETHER) } }\n  }\n}`",
  "quickstarts_javascript_node_ethereum_section3": "async function main() {\n  const stream = await client.graphql(operation, (message) => {\n    if (message.type === \"data\") {\n      const { undo, cursor, node: { hash, value, matchingCalls }} = message.data.searchTransactions\n      matchingCalls.forEach(({ from, to, value }) => {\n        console.log(`Transfer ${from} -> ${to} [${value} Ether]${undo ? \" REVERTED\" : \"\"}`)\n      })\n\n      // Mark stream at cursor location, on re-connect, we will start back at cursor\n      stream.mark({ cursor })\n    }\n\n    if (message.type === \"error\") {\n      console.log(\"An error occurred\", message.errors, message.terminal)\n    }\n\n    if (message.type === \"complete\") {\n      console.log(\"Completed\")\n    }\n  })\n\n  // Waits until the stream completes, or forever\n  await stream.join()\n  await client.release()\n}",
  "quickstarts_javascript_node_ethereum_section4": "main().catch((error) => console.log(\"Unexpected error\", error))",
  "quickstarts_python_ethereum_section1": "try:\n    # python3\n    from http.client import HTTPSConnection\nexcept ImportError:\n    # python2\n    from httplib import HTTPSConnection\n\nimport grpc\nimport json\nimport os\nimport ssl\nimport sys\n\nfrom graphql import graphql_pb2_grpc\nfrom graphql.graphql_pb2 import Request",
  "quickstarts_python_ethereum_section2": "def get_token(api_key):\n    connection = HTTPSConnection(\"auth.dfuse.io\")\n    connection.request('POST', '/v1/auth/issue', json.dumps({\"api_key\": api_key}), {'Content-type': 'application/json'})\n    response = connection.getresponse()\n\n    if response.status != 200:\n        raise Exception(\" Status: %s reason: %s\" % (response.status, response.reason))\n\n    token = json.loads(response.read().decode())['token']\n    connection.close()\n\n    return token",
  "quickstarts_python_ethereum_section3": "def create_client(token, endpoint):\n    channel = grpc.secure_channel(endpoint,\n        credentials = grpc.composite_channel_credentials(\n            grpc.ssl_channel_credentials(),\n            grpc.access_token_call_credentials(token)\n    ))\n\n    return graphql_pb2_grpc.GraphQLStub(channel)",
  "quickstarts_python_ethereum_section4": "OPERATION_ETH = \"\"\"subscription {\n  searchTransactions(indexName: CALLS, query: \"-value:0 type:call\", lowBlockNum: -1) {\n    undo cursor\n    node { hash matchingCalls { from to value(encoding:ETHER) } }\n  }\n}\"\"\"",
  "quickstarts_python_ethereum_section5": "def stream_ethereum(client):\n    # The client can be re-used for all requests, cache it at the appropriate level\n    stream = client.Execute(Request(query = OPERATION_ETH))\n\n    for rawResult in stream:\n        if rawResult.errors:\n            print(\"An error occurred\")\n            print(rawResult.errors)\n        else:\n            result = json.loads(rawResult.data)\n            for call in result['searchTransactions']['node']['matchingCalls']:\n                undo = result['searchTransactions']['undo']\n                print(\"Transfer %s -> %s [%s Ether]%s\" % (call['from'], call['to'], call['value'], \" REVERTED\" if undo else \"\"))",
  "quickstarts_python_ethereum_section6": "dfuse_api_key = os.environ.get(\"DFUSE_API_KEY\")\nif dfuse_api_key == None or dfuse_api_key == 'your dfuse api key here':\n    raise Exception('you must specify a DFUSE_API_KEY environment variable')\n\ntoken = get_token(dfuse_api_key)\n# The client can be re-used for all requests, cache it at the appropriate level\n\nclient = create_client(token, 'mainnet.eth.dfuse.io:443')\nstream_ethereum(client)",
  "quickstarts_python_eos_section1": "try:\n    # python3\n    from http.client import HTTPSConnection\nexcept ImportError:\n    # python2\n    from httplib import HTTPSConnection\n\nimport grpc\nimport json\nimport os\nimport ssl\nimport sys\n\nfrom graphql import graphql_pb2_grpc\nfrom graphql.graphql_pb2 import Request",
  "quickstarts_python_eos_section2": "def get_token(api_key):\n    connection = HTTPSConnection(\"auth.dfuse.io\")\n    connection.request('POST', '/v1/auth/issue', json.dumps({\"api_key\": api_key}), {'Content-type': 'application/json'})\n    response = connection.getresponse()\n\n    if response.status != 200:\n        raise Exception(\" Status: %s reason: %s\" % (response.status, response.reason))\n\n    token = json.loads(response.read().decode())['token']\n    connection.close()\n\n    return token",
  "quickstarts_python_eos_section3": "def create_client(endpoint):\n    dfuse_api_key = os.environ.get(\"DFUSE_API_KEY\")\n    if dfuse_api_key == None:\n        raise Exception(\"you must specify a DFUSE_API_KEY environment variable\")\n\n    channel = grpc.secure_channel(endpoint,\n        credentials = grpc.composite_channel_credentials(\n            grpc.ssl_channel_credentials(),\n            grpc.access_token_call_credentials(get_token(dfuse_api_key))\n    ))\n\n    return graphql_pb2_grpc.GraphQLStub(channel)",
  "quickstarts_python_eos_section4": "OPERATION_EOS = \"\"\"subscription {\n  searchTransactionsForward(query:\"receiver:eosio.token action:transfer\") {\n    undo cursor\n    trace { id matchingActions { json } }\n  }\n}\"\"\"",
  "quickstarts_python_eos_section5": "def stream_eosio():\n  \t# The client can be re-used for all requests, cache it at the appropriate level\n    client = create_client('mainnet.eos.dfuse.io:443')\n    stream = client.Execute(Request(query = OPERATION_EOS))\n\n    for rawResult in stream:\n        if rawResult.errors:\n            print(\"An error occurred\")\n            print(rawResult.errors)\n        else:\n            result = json.loads(rawResult.data)\n            for action in result['searchTransactionsForward']['trace']['matchingActions']:\n                undo = result['searchTransactionsForward']['undo']\n                data = action['json']\n                print(\"Transfer %s -> %s [%s]%s\" % (data['from'], data['to'], data['quantity'], \" REVERTED\" if undo else \"\"))",
  "quickstarts_python_eos_section6": "# DFUSE_API_KEY=\"server_abcdef12345678900000000000\" python main.py eosio|ethereum\nproto = \"\"\nif len(sys.argv) > 1:\n    proto = sys.argv[1].lower()\n\nif proto == \"ethereum\" or proto == \"ETH\":\n    stream_ethereum()\nelse:\n    stream_eosio()",
  "tutorials_eos_push-guaranteed_section1": "import { Api, JsonRpc } from \"eosjs\"\nimport { JsSignatureProvider } from \"eosjs/dist/eosjs-jssig\"\nimport { TextDecoder, TextEncoder } from \"text-encoding\"",
  "tutorials_eos_push-guaranteed_section2": "import fetch, { Request, RequestInit, Response } from \"node-fetch\"",
  "tutorials_eos_push-guaranteed_section3": "import { createDfuseClient } from \"@dfuse/client\"\n;(global as any).fetch = fetch\n;(global as any).WebSocket = {}\n\nconst config = readConfig()\nconst client = createDfuseClient({ apiKey: config.dfuseApiKey, network: config.network })",
  "tutorials_eos_push-guaranteed_section4": "const customizedFetch = async (input?: string | Request, init?: RequestInit): Promise<Response> => {\n  if (init === undefined) {\n    init = {}\n  }\n\n  if (init.headers === undefined) {\n    init.headers = {}\n  }\n\n  // This is highly optimized and cached, so while the token is fresh, this is very fast\n  const apiTokenInfo = await client.getTokenInfo()\n\n  const headers = init.headers as { [name: string]: string }\n  headers[\"Authorization\"] = `Bearer ${apiTokenInfo.token}`\n  headers[\"X-Eos-Push-Guarantee\"] = config.guaranteed\n\n  return fetch(input!, init)\n}",
  "tutorials_eos_push-guaranteed_section5": "async function main() {\n  const signatureProvider = new JsSignatureProvider([config.privateKey])\n  const rpc = new JsonRpc(client.endpoints.restUrl, { fetch: customizedFetch as any })\n  const api = new Api({\n    rpc,\n    signatureProvider,\n    textDecoder: new TextDecoder(),\n    textEncoder: new TextEncoder()\n  })\n\n  const transferAction = {\n    account: \"eosio.token\",\n    name: \"transfer\",\n    authorization: [\n      {\n        actor: config.transferFrom,\n        permission: \"active\"\n      }\n    ],\n    data: {\n      from: config.transferFrom,\n      to: config.transferTo,\n      quantity: config.transferQuantity,\n      memo: `Transaction with push guaranteed '${\n        config.guaranteed\n      }' from dfuse (https://docs.dfuse.io/#rest-api-post-push_transaction)`\n    }\n  }\n\n  console.log(\"Transfer action\", prettyJson(transferAction))\n\n  const startTime = new Date()\n  const result = await api.transact(\n    { actions: [transferAction] },\n    {\n      blocksBehind: 360,\n      expireSeconds: 3600\n    }\n  )\n  const endTime = new Date()\n\n  printResult(result, startTime, endTime)\n}",
  "tutorials_eos_push-guaranteed_section6": "function readConfig() {\n  const network = process.env.DFUSE_API_NETWORK || \"kylin.eos.dfuse.io\"\n  const guaranteed = process.env.PUSH_GUARANTEED || \"in-block\" // Or \"irreversible\", \"handoff:1\", \"handoffs:2\", \"handoffs:3\"\n  const transferTo = process.env.TRANSFER_TO_ACCOUNT || \"eoscanadacom\"\n  const transferQuantity = process.env.TRANSFER_QUANTITY || \"0.0001 EOS\"\n\n  const dfuseApiKey = process.env.DFUSE_API_KEY\n  if (dfuseApiKey === undefined) {\n    console.log(\n      \"You must have a 'process.env.DFUSE_API_KEY' environment variable containing your dfuse API key.\"\n    )\n    process.exit(1)\n  }\n\n  const privateKey = process.env.SIGNING_PRIVATE_KEY\n  if (privateKey === undefined) {\n    console.log(\n      \"You must have a 'SIGNING_PRIVATE_KEY' environment variable containing private used to sign.\"\n    )\n    process.exit(1)\n  }\n\n  const transferFrom = process.env.TRANSFER_FROM_ACCOUNT\n  if (transferFrom === undefined) {\n    console.log(\n      \"You must have a 'TRANSFER_FROM_ACCOUNT' environment variable containing account that is going to send token.\"\n    )\n    process.exit(1)\n  }\n\n  return {\n    network,\n    guaranteed,\n    dfuseApiKey: dfuseApiKey!,\n    privateKey: privateKey!,\n    transferFrom: transferFrom!,\n    transferTo,\n    transferQuantity\n  }\n}\n\nfunction printResult(result: any, startTime: Date, endTime: Date) {\n  console.log(\"Transaction push result\", prettyJson(result))\n  console.log()\n\n  const elapsed = (endTime.getTime() - startTime.getTime()) / 1000.0\n  console.log(`Pushed with guarenteed '${config.guaranteed}' in '${elapsed}' seconds`)\n\n  const networkMatch = client.endpoints.restUrl.match(\n    /https:\\/\\/(mainnet|testnet|kylin).eos.dfuse.io/\n  )\n  if (networkMatch !== null && networkMatch[1] != null) {\n    let network = networkMatch[1] + \".\"\n    if (network === \"mainnet\") {\n      network = \"\"\n    }\n\n    console.log(` - https://${network}eosq.app/tx/${result.transaction_id}`)\n  }\n}\n\nfunction prettyJson(input: any): string {\n  return JSON.stringify(input, null, 2)\n}\n\nmain()\n  .then(() => {\n    process.exit(0)\n  })\n  .catch((error) => {\n    console.log(\"An error occurred.\", prettyJson(error))\n    process.exit(1)\n  })",
  "tutorials_eth_lifecycle_css_section1": ".App {\n    text-align: left;\n    width:1080px;\n    margin:auto auto;\n    display: flex;\n    flex-direction: row;\n}\n\n.App .form {\n    padding-top:50px;\n\n    text-align: center;\n}\n\n.App .data {\n    padding:50px;\n    width: 100%;\n}\n\n.App .data pre {\n    padding:10px;\n    white-space: pre-wrap;\n    white-space: -moz-pre-wrap;\n    white-space: -o-pre-wrap;\n    word-wrap: break-word;\n}\n\n\n.trx-id {\n    padding: 18.5px 14px;\n    height: 1.1875em;\n    background: none;\n    box-sizing: content-box;\n    border:thin #878787 solid;\n    width:300px;\n    margin-bottom:10px;\n}\n\n.submit {\n    color: #fff;\n    height: 40px;\n    font-size: 16px;\n    box-shadow: none;\n    line-height: 16px;\n    padding-top: 10px;\n    padding-left: 40px;\n    border-radius: 20px;\n    padding-right: 40px;\n    padding-bottom: 10px;\n    text-transform: none;\n    background-color: #ff4660;\n}\n\n.transition {\n    padding:7px;\n    border-radius: 2px;\n    background: #f8f8fa;\n    border: thin solid #f8f9fa;\n    margin-top: 10px;\n    margin-bottom: 10px;\n\n}\n.error {\n    color: #721c24;\n    background-color: #f8d7da;\n    border-color: #f5c6cb;\n    padding:20px;\n    width: 100%;\n}\n\n.state {\n    color: #fff;\n    background-color: #17a2b8;\n    display: inline-block;\n    padding: .25em .4em;\n    font-size: 75%;\n    font-weight: 700;\n    line-height: 1;\n    text-align: center;\n    white-space: nowrap;\n    vertical-align: baseline;\n    border-radius: .25rem;\n}",
  "tutorials_eth_lifecycle_js_section1": "import React, { useState } from 'react';\nimport { createDfuseClient } from \"@dfuse/client\"\nimport './App.css';\nfunction App() {    const dfuseClient = createDfuseClient({\n        apiKey: \"<YOUR_API_KEY_HERE>\",\n        network: \"mainnet.eth.dfuse.io\"\n    });    let streamTransactionQuery = `\n     subscription($hash: String!){\n      transactionLifecycle(hash: $hash){\n        previousState\n        currentState\n        transitionName\n        transition{\n          __typename\n\n        ... on TrxTransitionInit {\n            transaction {\n            ...TransactionFragment\n            }\n            blockHeader {\n            ...BlockHeaderFragment\n            }\n            trace {\n            ...TransactionTraceFragment\n            }\n            confirmations\n            replacedById\n          }\n\n        ...on TrxTransitionPooled {\n            transaction {\n            ...TransactionFragment\n            }\n          }\n\n        ...on TrxTransitionMined {\n            blockHeader {\n            ...BlockHeaderFragment\n            }\n            trace {\n            ...TransactionTraceFragment\n            }\n            confirmations\n          }\n\n        ...on TrxTransitionForked {\n            transaction {\n            ...TransactionFragment\n            }\n          }\n\n        ...on TrxTransitionConfirmed {\n            confirmations\n          }\n\n        ...on TrxTransitionReplaced {\n            replacedById\n          }\n\n        }\n      }\n    }\n\n    fragment TransactionFragment on Transaction {\n      hash\n      from\n      to\n      nonce\n      gasPrice\n      gasLimit\n      value\n      inputData\n      signature {\n        v\n        s\n        r\n      }\n    }\n\n    fragment TransactionTraceFragment on TransactionTrace {\n      hash\n      from\n      to\n      nonce\n      gasPrice\n      gasLimit\n      value\n      inputData\n      signature {\n        v\n        s\n        r\n      }\n      cumulativeGasUsed\n      publicKey\n      index\n      create\n      outcome\n    }\n\n    fragment BlockHeaderFragment on BlockHeader {\n      parentHash\n      unclesHash\n      coinbase\n      stateRoot\n      transactionsRoot\n      receiptRoot\n      logsBloom\n      difficulty\n      number\n      gasLimit\n      gasUsed\n      timestamp\n      extraData\n      mixHash\n      nonce\n      hash\n    }`;    const [transactionHash, setTransactionHash] = useState('');\n    const [transitions, setTransitions] = useState([]);\n    const [state, setState] = useState(\"initialize\");\n    const [error, setError] = useState(\"\");    async function fetchTransaction() {\n        setState(\"streaming\");\n        setError(\"\");\n        setTransitions([]);\n        var currentTransitions = [];\n        var count = 0;\n\n        const stream = await dfuseClient.graphql(streamTransactionQuery, (message) => {\n\n            if (message.type === \"error\") {\n                setError(message.errors[0]['message'])\n            }\n\n            if (message.type === \"data\") {\n                var newTransition = {\n                    key: `transition-${count}`,\n                    transition: message['data']['transactionLifecycle']['transitionName'],\n                    from: message['data']['transactionLifecycle']['previousState'],\n                    to: message['data']['transactionLifecycle']['currentState'],\n                    data: message['data']\n                };\n                count++;\n                currentTransitions = [...currentTransitions, newTransition]\n                setTransitions(currentTransitions.reverse());\n            }\n\n            if (message.type === \"complete\") {\n                setState(\"completed\");\n            }\n        },{\n            variables: {\n                hash:  transactionHash\n            }\n        });\n\n        await stream.join() // awaits stream completion, which is never for this operation\n    }    return (\n        <div className=\"App\">\n            <div className=\"form\">\n                <p>Enter a transaction hash</p>\n                <input type={\"text\"} value={transactionHash} onChange={(e) => setTransactionHash(e.target.value)} className={'trx-id'} /> <br/>\n                <button className=\"submit\" onClick={() => fetchTransaction()}>Search Transaction</button>\n            </div>\n            <div className=\"data\">\n                {   (error !== \"\") && (<div className='error'>{ error }</div>) }\n                {   (error === \"\") &&\n                    ((state === \"streaming\") ||  (state === \"completed\")) &&\n                    (\n                        <div>\n                            <label className=\"state\">{state}</label>\n                            <div>\n                                {\n                                    transitions.map((transition) => (\n                                        <div className=\"transition\" key={transition.key}>\n                                            <strong>Transition:</strong> {transition.transition} <br/>\n                                            <strong>Previous State:</strong> {transition.from} <br/>\n                                            <strong>Current State:</strong> {transition.to} <br/>\n                                            <pre key={transition.key}>  { JSON.stringify(transition.data, null, 1) } </pre>\n                                        </div>\n                                    ))\n                                }\n                            </div>\n                        </div>\n                    )\n                }\n                {   (state !== \"streaming\") &&\n                    (\n                        <div>Enter a transaction hash to begin</div>\n                    )\n                }\n            </div>\n        </div>\n    );\n}\nexport default App;",
  "tutorials_eth_lifecycle_js_section2": "import React, { useState } from 'react';\nimport { createDfuseClient } from \"@dfuse/client\"\nimport './App.css';",
  "tutorials_eth_lifecycle_js_section3": "    const dfuseClient = createDfuseClient({\n        apiKey: \"<YOUR_API_KEY_HERE>\",\n        network: \"mainnet.eth.dfuse.io\"\n    });",
  "tutorials_eth_lifecycle_js_section4": "    let streamTransactionQuery = `\n     subscription($hash: String!){\n      transactionLifecycle(hash: $hash){\n        previousState\n        currentState\n        transitionName\n        transition{\n          __typename\n\n        ... on TrxTransitionInit {\n            transaction {\n            ...TransactionFragment\n            }\n            blockHeader {\n            ...BlockHeaderFragment\n            }\n            trace {\n            ...TransactionTraceFragment\n            }\n            confirmations\n            replacedById\n          }\n\n        ...on TrxTransitionPooled {\n            transaction {\n            ...TransactionFragment\n            }\n          }\n\n        ...on TrxTransitionMined {\n            blockHeader {\n            ...BlockHeaderFragment\n            }\n            trace {\n            ...TransactionTraceFragment\n            }\n            confirmations\n          }\n\n        ...on TrxTransitionForked {\n            transaction {\n            ...TransactionFragment\n            }\n          }\n\n        ...on TrxTransitionConfirmed {\n            confirmations\n          }\n\n        ...on TrxTransitionReplaced {\n            replacedById\n          }\n\n        }\n      }\n    }\n\n    fragment TransactionFragment on Transaction {\n      hash\n      from\n      to\n      nonce\n      gasPrice\n      gasLimit\n      value\n      inputData\n      signature {\n        v\n        s\n        r\n      }\n    }\n\n    fragment TransactionTraceFragment on TransactionTrace {\n      hash\n      from\n      to\n      nonce\n      gasPrice\n      gasLimit\n      value\n      inputData\n      signature {\n        v\n        s\n        r\n      }\n      cumulativeGasUsed\n      publicKey\n      index\n      create\n      outcome\n    }\n\n    fragment BlockHeaderFragment on BlockHeader {\n      parentHash\n      unclesHash\n      coinbase\n      stateRoot\n      transactionsRoot\n      receiptRoot\n      logsBloom\n      difficulty\n      number\n      gasLimit\n      gasUsed\n      timestamp\n      extraData\n      mixHash\n      nonce\n      hash\n    }`;",
  "tutorials_eth_lifecycle_js_section5": "    const [transactionHash, setTransactionHash] = useState('');\n    const [transitions, setTransitions] = useState([]);\n    const [state, setState] = useState(\"initialize\");\n    const [error, setError] = useState(\"\");",
  "tutorials_eth_lifecycle_js_section6": "    async function fetchTransaction() {\n        setState(\"streaming\");\n        setError(\"\");\n        setTransitions([]);\n        var currentTransitions = [];\n        var count = 0;\n\n        const stream = await dfuseClient.graphql(streamTransactionQuery, (message) => {\n\n            if (message.type === \"error\") {\n                setError(message.errors[0]['message'])\n            }\n\n            if (message.type === \"data\") {\n                var newTransition = {\n                    key: `transition-${count}`,\n                    transition: message['data']['transactionLifecycle']['transitionName'],\n                    from: message['data']['transactionLifecycle']['previousState'],\n                    to: message['data']['transactionLifecycle']['currentState'],\n                    data: message['data']\n                };\n                count++;\n                currentTransitions = [...currentTransitions, newTransition]\n                setTransitions(currentTransitions.reverse());\n            }\n\n            if (message.type === \"complete\") {\n                setState(\"completed\");\n            }\n        },{\n            variables: {\n                hash:  transactionHash\n            }\n        });\n\n        await stream.join() // awaits stream completion, which is never for this operation\n    }",
  "tutorials_eth_lifecycle_js_section7": "    return (\n        <div className=\"App\">\n            <div className=\"form\">\n                <p>Enter a transaction hash</p>\n                <input type={\"text\"} value={transactionHash} onChange={(e) => setTransactionHash(e.target.value)} className={'trx-id'} /> <br/>\n                <button className=\"submit\" onClick={() => fetchTransaction()}>Search Transaction</button>\n            </div>\n            <div className=\"data\">\n                {   (error !== \"\") && (<div className='error'>{ error }</div>) }\n                {   (error === \"\") &&\n                    ((state === \"streaming\") ||  (state === \"completed\")) &&\n                    (\n                        <div>\n                            <label className=\"state\">{state}</label>\n                            <div>\n                                {\n                                    transitions.map((transition) => (\n                                        <div className=\"transition\" key={transition.key}>\n                                            <strong>Transition:</strong> {transition.transition} <br/>\n                                            <strong>Previous State:</strong> {transition.from} <br/>\n                                            <strong>Current State:</strong> {transition.to} <br/>\n                                            <pre key={transition.key}>  { JSON.stringify(transition.data, null, 1) } </pre>\n                                        </div>\n                                    ))\n                                }\n                            </div>\n                        </div>\n                    )\n                }\n                {   (state !== \"streaming\") &&\n                    (\n                        <div>Enter a transaction hash to begin</div>\n                    )\n                }\n            </div>\n        </div>\n    );\n}",
  "tutorials_eth_lifecycle_graphql_section1": "subscription {\n    transactionLifecycle(hash: \"0x3be3b44ae48a074d3b79e3054bb3b62b5c5e5a8fc2210cd1dc7c7932ae5addcd\"){        previousState\n        currentState\n        transitionName\n        transition {            __typename\n\n            ... on TrxTransitionInit {\n                transaction {\n                    ...TransactionFragment\n                }\n                blockHeader {\n                    ...BlockHeaderFragment\n                }\n                trace {\n                    ...TransactionTraceFragment\n                }\n                confirmations\n                replacedById\n            }\n\n            ...on TrxTransitionPooled {\n                transaction {\n                    ...TransactionFragment\n                }\n            }\n\n            ...on TrxTransitionMined {\n                blockHeader {\n                    ...BlockHeaderFragment\n                }\n                trace {\n                    ...TransactionTraceFragment\n                }\n                confirmationsher\n            }            ...on TrxTransitionForked {\n                transaction {\n                    ...TransactionFragment\n                }\n            }            ...on TrxTransitionConfirmed {\n                confirmations\n            }\n\n            ...on TrxTransitionReplaced {\n                replacedById\n            }\n\n        }\n    }\n}\nfragment TransactionFragment on Transaction {\n    hash\n    from\n    to\n    nonce\n    gasPrice\n    gasLimit\n    value\n    inputData\n    signature {\n        v\n        s\n        r\n    }\n}\nfragment TransactionTraceFragment on TransactionTrace {\n    hash\n    from\n    to\n    nonce\n    gasPrice\n    gasLimit\n    value\n    inputData\n    signature {\n        v\n        s\n        r\n    }\n    cumulativeGasUsed\n    publicKey\n    index\n    create\n    outcome\n}\n\nfragment BlockHeaderFragment on BlockHeader {\n    parentHash\n    unclesHash\n    coinbase\n    stateRoot\n    transactionsRoot\n    receiptRoot\n    logsBloom\n    difficulty\n    number\n    gasLimit\n    gasUsed\n    timestamp\n    extraData\n    mixHash\n    nonce\n    hash\n}",
  "tutorials_eth_lifecycle_graphql_section2": "subscription {\n    transactionLifecycle(hash: \"0x3be3b44ae48a074d3b79e3054bb3b62b5c5e5a8fc2210cd1dc7c7932ae5addcd\"){",
  "tutorials_eth_lifecycle_graphql_section3": "subscription {\n    transactionLifecycle(hash: \"0x3be3b44ae48a074d3b79e3054bb3b62b5c5e5a8fc2210cd1dc7c7932ae5addcd\"){        previousState\n        currentState\n        transitionName\n        transition {",
  "tutorials_eth_lifecycle_graphql_section4": "            ...on TrxTransitionForked {\n                transaction {\n                    ...TransactionFragment\n                }\n            }",
  "tutorials_eth_lifecycle_graphql_section5": "fragment TransactionFragment on Transaction {\n    hash\n    from\n    to\n    nonce\n    gasPrice\n    gasLimit\n    value\n    inputData\n    signature {\n        v\n        s\n        r\n    }\n}",
  "tutorials_eth_search_css_section1": ".App {\n    text-align: left;\n    width:1080px;\n    margin:auto auto;\n    display: flex;\n    flex-direction: row;\n}\n\n.App .form {\n    padding-top:50px;\n\n    text-align: center;\n}\n\n.App .data {\n    padding:50px;\n    width: 100%;\n}\n\n.App .data pre {\n    padding:10px;\n    white-space: pre-wrap;\n    white-space: -moz-pre-wrap;\n    white-space: -o-pre-wrap;\n    word-wrap: break-word;\n}\n\n\n.trx-id {\n    padding: 18.5px 14px;\n    height: 1.1875em;\n    background: none;\n    box-sizing: content-box;\n    border:thin #878787 solid;\n    width:300px;\n    margin-bottom:10px;\n}\n\n.submit {\n    color: #fff;\n    height: 40px;\n    font-size: 16px;\n    box-shadow: none;\n    line-height: 16px;\n    padding-top: 10px;\n    padding-left: 40px;\n    border-radius: 20px;\n    padding-right: 40px;\n    padding-bottom: 10px;\n    text-transform: none;\n    background-color: #ff4660;\n}\n\n.transition {\n    padding:7px;\n    border-radius: 2px;\n    background: #f8f8fa;\n    border: thin solid #f8f9fa;\n    margin-top: 10px;\n    margin-bottom: 10px;\n\n}\n.error {\n    color: #721c24;\n    background-color: #f8d7da;\n    border-color: #f5c6cb;\n    padding:20px;\n    width: 100%;\n}\n\n.state {\n    color: #fff;\n    background-color: #17a2b8;\n    display: inline-block;\n    padding: .25em .4em;\n    font-size: 75%;\n    font-weight: 700;\n    line-height: 1;\n    text-align: center;\n    white-space: nowrap;\n    vertical-align: baseline;\n    border-radius: .25rem;\n}",
  "tutorials_eth_search_js_section1": "import React, { useState } from 'react';\nimport { createDfuseClient } from '@dfuse/client';\nimport './App.css';\nfunction App() {  const dfuseClient = createDfuseClient({\n    apiKey: '<YOUR API KEY HERE>',\n    network: 'mainnet.eth.dfuse.io'\n  });  const FlatCallFragment = `fragment FlatCallFragment on Call {\n    index\n    depth\n    parentIndex\n    callType\n    from\n    to\n    value(encoding:WEI)\n    gasConsumed\n    inputData\n    returnData\n    logs {\n      address\n      topics\n      data\n    }\n    balanceChanges{\n      reason\n      address\n      oldValue(encoding:WEI)\n      newValue(encoding:WEI)\n    }\n    storageChanges{\n      key\n      address\n      oldValue\n      newValue\n    }\n  }\n  `;\n\n  const searchTransactionsQuery = `query ($query: String!, $indexName:TRANSACTIONS_INDEX_NAME!, $lowBlockNum: Int64, $highBlockNum: Int64, $sort: SORT!, $cursor: String!, $limit: Int64!){\n    searchTransactions(query: $query, indexName: $indexName, lowBlockNum: $lowBlockNum, highBlockNum: $highBlockNum, sort: $sort,  cursor: $cursor, limit: $limit) {\n      pageInfo {\n        startCursor\n        endCursor\n      }\n      edges {\n        undo\n        cursor\n        node {\n          value(encoding:WEI)\n          hash\n          nonce\n          gasLimit\n          gasUsed\n          gasPrice(encoding:WEI)\n          to\n          block {\n            number\n            hash\n            header {\n              timestamp\n            }\n          }\n          flatCalls {\n            ...FlatCallFragment\n          }\n        }\n      }\n    }\n  }\n\n  ${FlatCallFragment}`;  const [query, setQuery] = useState('');\n  const [transactions, setTransactions] = useState([]);\n  const [state, setState] = useState('initialize');\n  const [error, setError] = useState('');\n  function parseSQE(input) {\n    return {\n      query: input.trim()\n    };\n  }\n  async function searchTransactions() {\n    setTransactions([]);\n    setState('searching');\n    setError('');\n    const parsedSQE = parseSQE(query);\n    try {\n      const response = await dfuseClient.graphql(searchTransactionsQuery, {\n        variables: {\n          query: parsedSQE.query,\n          indexName: 'CALLS',\n          lowBlockNum: '0',\n          highBlockNum: '-1',\n          sort: 'DESC',\n          limit: '10',\n          cursor: ''\n        }\n      });\n\n      if (response.errors) {\n        throw response.errors;\n      }\n\n      const edges = response.data.searchTransactions.edges || [];\n      if (edges.length <= 0) {\n        setError('Oops nothing found');\n        return;\n      }\n      setTransactions(edges.map(edge => edge.node));\n      setState('completed');\n    } catch (errors) {\n      setError(JSON.stringify(errors));\n      setState('completed');\n    }\n\n    dfuseClient.release();\n  }  return (\n    <div className='App'>\n      <div className='form'>\n        <p>Search Ethereum Data</p>\n        <input\n          type={'text'}\n          value={query}\n          onChange={e => setQuery(e.target.value)}\n          className={'trx-id'}\n          placeholder='Enter search query'\n        />{' '}\n        <br />\n        <button className='submit' onClick={() => searchTransactions()}>\n          Run search\n        </button>\n        <hr />\n        <a\n          href='https://docs.dfuse.io/guides/core-concepts/search-query-language/'\n          target='_blank'\n        >\n          Search Language Reference\n        </a>\n        <br />\n        <a\n          href='https://docs.dfuse.io/ethereum/public-apis/reference/search/terms/'\n          target='_blank'\n        >\n          Ethereum Search Terms\n        </a>\n      </div>\n      <div className='data'>\n        {state !== 'searching' && <p>Enter a search query to begin</p>}\n        {error !== '' && <div className='error'>{error}</div>}\n        <br />\n        {error === '' && (state === 'searching' || state === 'completed') && (\n          <div>\n            <label className='state'>{state}</label>\n            <div>\n              {transactions.map((transaction, index) => (\n                <div className='transaction' key={index}>\n                  <pre key={index}>{JSON.stringify(transaction, null, 1)}</pre>\n                  <hr />\n                </div>\n              ))}\n            </div>\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}\nexport default App;",
  "tutorials_eth_search_js_section2": "import React, { useState } from 'react';\nimport { createDfuseClient } from '@dfuse/client';\nimport './App.css';",
  "tutorials_eth_search_js_section3": "  const dfuseClient = createDfuseClient({\n    apiKey: '<YOUR API KEY HERE>',\n    network: 'mainnet.eth.dfuse.io'\n  });",
  "tutorials_eth_search_js_section4": "  const FlatCallFragment = `fragment FlatCallFragment on Call {\n    index\n    depth\n    parentIndex\n    callType\n    from\n    to\n    value(encoding:WEI)\n    gasConsumed\n    inputData\n    returnData\n    logs {\n      address\n      topics\n      data\n    }\n    balanceChanges{\n      reason\n      address\n      oldValue(encoding:WEI)\n      newValue(encoding:WEI)\n    }\n    storageChanges{\n      key\n      address\n      oldValue\n      newValue\n    }\n  }\n  `;\n\n  const searchTransactionsQuery = `query ($query: String!, $indexName:TRANSACTIONS_INDEX_NAME!, $lowBlockNum: Int64, $highBlockNum: Int64, $sort: SORT!, $cursor: String!, $limit: Int64!){\n    searchTransactions(query: $query, indexName: $indexName, lowBlockNum: $lowBlockNum, highBlockNum: $highBlockNum, sort: $sort,  cursor: $cursor, limit: $limit) {\n      pageInfo {\n        startCursor\n        endCursor\n      }\n      edges {\n        undo\n        cursor\n        node {\n          value(encoding:WEI)\n          hash\n          nonce\n          gasLimit\n          gasUsed\n          gasPrice(encoding:WEI)\n          to\n          block {\n            number\n            hash\n            header {\n              timestamp\n            }\n          }\n          flatCalls {\n            ...FlatCallFragment\n          }\n        }\n      }\n    }\n  }\n\n  ${FlatCallFragment}`;",
  "tutorials_eth_search_js_section5": "  const [query, setQuery] = useState('');\n  const [transactions, setTransactions] = useState([]);\n  const [state, setState] = useState('initialize');\n  const [error, setError] = useState('');",
  "tutorials_eth_search_js_section6": "  async function searchTransactions() {\n    setTransactions([]);\n    setState('searching');\n    setError('');\n    const parsedSQE = parseSQE(query);\n    try {\n      const response = await dfuseClient.graphql(searchTransactionsQuery, {\n        variables: {\n          query: parsedSQE.query,\n          indexName: 'CALLS',\n          lowBlockNum: '0',\n          highBlockNum: '-1',\n          sort: 'DESC',\n          limit: '10',\n          cursor: ''\n        }\n      });\n\n      if (response.errors) {\n        throw response.errors;\n      }\n\n      const edges = response.data.searchTransactions.edges || [];\n      if (edges.length <= 0) {\n        setError('Oops nothing found');\n        return;\n      }\n      setTransactions(edges.map(edge => edge.node));\n      setState('completed');\n    } catch (errors) {\n      setError(JSON.stringify(errors));\n      setState('completed');\n    }\n\n    dfuseClient.release();\n  }",
  "tutorials_eth_search_js_section7": "  return (\n    <div className='App'>\n      <div className='form'>\n        <p>Search Ethereum Data</p>\n        <input\n          type={'text'}\n          value={query}\n          onChange={e => setQuery(e.target.value)}\n          className={'trx-id'}\n          placeholder='Enter search query'\n        />{' '}\n        <br />\n        <button className='submit' onClick={() => searchTransactions()}>\n          Run search\n        </button>\n        <hr />\n        <a\n          href='https://docs.dfuse.io/guides/core-concepts/search-query-language/'\n          target='_blank'\n        >\n          Search Language Reference\n        </a>\n        <br />\n        <a\n          href='https://docs.dfuse.io/ethereum/public-apis/reference/search/terms/'\n          target='_blank'\n        >\n          Ethereum Search Terms\n        </a>\n      </div>\n      <div className='data'>\n        {state !== 'searching' && <p>Enter a search query to begin</p>}\n        {error !== '' && <div className='error'>{error}</div>}\n        <br />\n        {error === '' && (state === 'searching' || state === 'completed') && (\n          <div>\n            <label className='state'>{state}</label>\n            <div>\n              {transactions.map((transaction, index) => (\n                <div className='transaction' key={index}>\n                  <pre key={index}>{JSON.stringify(transaction, null, 1)}</pre>\n                  <hr />\n                </div>\n              ))}\n            </div>\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}",
  "tutorials_eth_stream_css_section1": ".App {\n  text-align: center;\n}\n\n.App-header {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  justify-content: center;\n  color: white;\n}\n\n.App-error {\n  display: block;\n  color: firebrick;\n  font-size: 0.85rem;\n  margin: 0.25rem 0;\n  text-align: left;\n}\n\n.App-main {\n  width: 60%;\n  margin: 0.25rem auto;\n}\n\n.App-infinite-container {\n  border: 2px solid #FF4661;\n  padding: 0.75rem 0.5rem;\n  height: 500px;\n  overflow-x: hidden;\n  overflow-y: scroll;\n}\n\n.App-transfer {\n  display: block;\n  color: #2d234c;\n  font-size: 0.85rem;\n  margin: 0.25rem 0;\n  text-align: left;\n}\n\n.App-button {\n  background-color: #F3F3F7;\n  border: 2px solid #FF4661;\n  color: #FF4661;\n  padding: 0.5rem;\n  margin: 0.25rem;\n  font-size: 1rem;\n  font-weight: 700;\n}\n\n.App-status {\n  color: #FF4661;\n  padding: 0.5rem 0;\n  margin: 0 0;\n  font-size: 1rem;\n  text-align: left;\n}",
  "tutorials_eth_stream_js_section1": "import React, { useState } from 'react';\nimport { createDfuseClient } from '@dfuse/client';\nimport './App.css';",
  "tutorials_eth_stream_js_section2": "  const dfuseClient = createDfuseClient({\n    apiKey,\n    network,\n    streamClientOptions: {\n      socketOptions: {\n        onClose: onClose,\n        onError: onError\n      }\n    }\n  });",
  "tutorials_eth_stream_js_section3": "  const streamTransfersQuery = `subscription($cursor: String) {\n      searchTransactions(indexName: CALLS, query: \"-value:0\", sort: ASC, limit: 100, cursor: $cursor) {\n        undo cursor\n        node { hash from to value(encoding: ETHER) }\n      }\n    }`;",
  "tutorials_eth_stream_js_section4": "  const [transfers, setTransfers] = useState([]);\n  const [state, setState] = useState('initialize');\n  const [errors, setErrors] = useState([]);\n  const [stream, setStream] = useState(undefined);",
  "tutorials_eth_stream_js_section5": "  const streamTransfers = async () => {\n    setTransfers([]);\n    setErrors([]);\n    setState('connected');\n    setErrors('');\n    let currentTransfers = [];\n    try {\n      const stream = await dfuseClient.graphql(\n        streamTransfersQuery,\n        async message => {\n          if (message.type === 'error') {\n            setErrors([\n              'An error occurred',\n              ...message.errors.map(error => error.message),\n              ...errors\n            ]);\n          }\n\n          if (message.type === 'data') {\n            const {\n              node: newTransfer,\n              cursor\n            } = message.data.searchTransactions;\n\n            currentTransfers = [newTransfer, ...currentTransfers];\n            setTransfers(currentTransfers);\n            stream.mark({ cursor });\n          }\n\n          if (message.type === 'complete') {\n            setState('completed');\n          }\n        }\n      );\n      setStream(stream);\n    } catch (errors) {\n      setErrors(JSON.stringify(errors));\n      setState('completed');\n    }\n  };",
  "tutorials_eth_stream_js_section6": "  const onStop = async () => {\n    setState('completed');\n    if (stream === undefined) {\n      return;\n    }\n    try {\n      await stream.close();\n      setStream(undefined);\n    } catch (error) {\n      setErrors(\n        `Unable to disconnect socket correctly: \n          ${JSON.stringify(error)}\n        `\n      );\n    }\n  };\n\n  const onClose = () => {\n    setState('completed');\n  };\n\n  const onError = error => {\n    setErrors(\n      `Unable to disconnect socket correctly: \n      ${JSON.stringify(error)}\n    `\n    );\n  };",
  "tutorials_eth_stream_js_section7": "  const renderTransfer = (transfer, index) => {\n    const { hash, from, to, value } = transfer;\n    return hash ? (\n      <code key={index} className='App-transfer'>\n        Transfer\n        <br />\n        {`From: ${from} -> To: ${to}`}\n        <br />\n        {`Value: ${value} Hash: ${hash}`}\n        <hr />\n      </code>\n    ) : (\n      <code key={index} className='App-transfer'>\n        {transfer}\n      </code>\n    );\n  };\n\n  const renderTransfers = () => {\n    return (\n      <div className='App-infinite-container'>\n        {transfers.length <= 0\n          ? renderTransfer('Nothing yet, start by hitting Launch!')\n          : transfers.reverse().map(renderTransfer)}\n      </div>\n    );\n  };\n\n  const renderError = (error, index) => {\n    if (error === '') {\n      return <br key={index} className='App-error' />;\n    }\n\n    return (\n      <code key={index} className='App-error'>\n        {error}\n      </code>\n    );\n  };\n\n  const renderErrors = () => {\n    if (errors.length <= 0) {\n      return null;\n    }\n\n    return <div className='App-container'>{errors.map(renderError)}</div>;\n  };\n\n  return (\n    <div className='App'>\n      <header className='App-header'>\n        <h2>Stream Ethereum Transfers</h2>\n        {renderErrors()}\n        <div className='App-buttons'>\n          <button className='App-button' onClick={streamTransfers}>\n            Launch\n          </button>\n          <button className='App-button' onClick={onStop}>\n            Stop\n          </button>\n        </div>\n        <main className='App-main'>\n          <p className='App-status'>\n            {`Connected: ${\n              state === 'connected'\n                ? 'Connected (Showing last 100 transfers)'\n                : 'Disconnected'\n            }`}\n          </p>\n          {renderTransfers()}\n        </main>\n      </header>\n    </div>\n  );\n}",
  "tutorials_eth_stream_js_section8": "import React, { useState } from 'react';\nimport { createDfuseClient } from '@dfuse/client';\nimport './App.css';\nconst apiKey = process.env.REACT_APP_DFUSE_API_KEY;\nconst network = process.env.REACT_APP_DFUSE_NETWORK || 'mainnet.eth.dfuse.io';\n\nfunction App() {  const dfuseClient = createDfuseClient({\n    apiKey,\n    network,\n    streamClientOptions: {\n      socketOptions: {\n        onClose: onClose,\n        onError: onError\n      }\n    }\n  });  const streamTransfersQuery = `subscription($cursor: String) {\n      searchTransactions(indexName: CALLS, query: \"-value:0\", sort: ASC, limit: 100, cursor: $cursor) {\n        undo cursor\n        node { hash from to value(encoding: ETHER) }\n      }\n    }`;  const [transfers, setTransfers] = useState([]);\n  const [state, setState] = useState('initialize');\n  const [errors, setErrors] = useState([]);\n  const [stream, setStream] = useState(undefined);  const streamTransfers = async () => {\n    setTransfers([]);\n    setErrors([]);\n    setState('connected');\n    setErrors('');\n    let currentTransfers = [];\n    try {\n      const stream = await dfuseClient.graphql(\n        streamTransfersQuery,\n        async message => {\n          if (message.type === 'error') {\n            setErrors([\n              'An error occurred',\n              ...message.errors.map(error => error.message),\n              ...errors\n            ]);\n          }\n\n          if (message.type === 'data') {\n            const {\n              node: newTransfer,\n              cursor\n            } = message.data.searchTransactions;\n\n            currentTransfers = [newTransfer, ...currentTransfers];\n            setTransfers(currentTransfers);\n            stream.mark({ cursor });\n          }\n\n          if (message.type === 'complete') {\n            setState('completed');\n          }\n        }\n      );\n      setStream(stream);\n    } catch (errors) {\n      setErrors(JSON.stringify(errors));\n      setState('completed');\n    }\n  };  const onStop = async () => {\n    setState('completed');\n    if (stream === undefined) {\n      return;\n    }\n    try {\n      await stream.close();\n      setStream(undefined);\n    } catch (error) {\n      setErrors(\n        `Unable to disconnect socket correctly: \n          ${JSON.stringify(error)}\n        `\n      );\n    }\n  };\n\n  const onClose = () => {\n    setState('completed');\n  };\n\n  const onError = error => {\n    setErrors(\n      `Unable to disconnect socket correctly: \n      ${JSON.stringify(error)}\n    `\n    );\n  };  const renderTransfer = (transfer, index) => {\n    const { hash, from, to, value } = transfer;\n    return hash ? (\n      <code key={index} className='App-transfer'>\n        Transfer\n        <br />\n        {`From: ${from} -> To: ${to}`}\n        <br />\n        {`Value: ${value} Hash: ${hash}`}\n        <hr />\n      </code>\n    ) : (\n      <code key={index} className='App-transfer'>\n        {transfer}\n      </code>\n    );\n  };\n\n  const renderTransfers = () => {\n    return (\n      <div className='App-infinite-container'>\n        {transfers.length <= 0\n          ? renderTransfer('Nothing yet, start by hitting Launch!')\n          : transfers.reverse().map(renderTransfer)}\n      </div>\n    );\n  };\n\n  const renderError = (error, index) => {\n    if (error === '') {\n      return <br key={index} className='App-error' />;\n    }\n\n    return (\n      <code key={index} className='App-error'>\n        {error}\n      </code>\n    );\n  };\n\n  const renderErrors = () => {\n    if (errors.length <= 0) {\n      return null;\n    }\n\n    return <div className='App-container'>{errors.map(renderError)}</div>;\n  };\n\n  return (\n    <div className='App'>\n      <header className='App-header'>\n        <h2>Stream Ethereum Transfers</h2>\n        {renderErrors()}\n        <div className='App-buttons'>\n          <button className='App-button' onClick={streamTransfers}>\n            Launch\n          </button>\n          <button className='App-button' onClick={onStop}>\n            Stop\n          </button>\n        </div>\n        <main className='App-main'>\n          <p className='App-status'>\n            {`Connected: ${\n              state === 'connected'\n                ? 'Connected (Showing last 100 transfers)'\n                : 'Disconnected'\n            }`}\n          </p>\n          {renderTransfers()}\n        </main>\n      </header>\n    </div>\n  );\n}\nexport default App;"
}